## 동시성 문제 보고서
### 1. 개요
- **문제 요약:** 포인트 충전, 결제, 쿠폰 발급, 재고 관리와 같은 기능들에서 다수의 요청이 동시에 처리될 때 데이터 불일치 현상이 발생하고 있다. 이로 인해 포인트 잔액의 부정확한 계산, 단일 주문에 대한 이중 결제, 수량 이상의 쿠폰 발급, 재고의 음수 처리 등 데이터의 정합성을 해치는 문제들이 나타나고 있다.
- **해결 방안 요약:** 동시성 문제를 해결하기 위해, 각 기능의 특성에 맞는 락(Lock) 전략을 선택적으로 적용하여 해결한다.
  - **낙관적 락 적용** : 포인트 충전, 주문, 결제
  - **비관적 락 적용** : 쿠폰 발급, 재고 관리

이처럼 각 기능의 특성과 예상되는 부하를 고려하여 두 가지 락 방식을 조합하면 시스템의 전체적인 성능을 유지하면서도 데이터의 정합성을 효과적으로 확보할 수 있다.


### 2. 문제 식별
- **발생 현상:**

| 구분     | 상황                                                                        | 문제점                                                                                                                                     |
|--------|---------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------|
| 포인트 충전 | 동일한 사용자가 짧은 시간 안에 <br/>중복으로 포인트를 충전                                       | 데이터베이스의 사용자 잔액이 정상적으로 업데이트되지 않고 일부 충전 내역이 누락되어 데이터 불일치가 발생할 수 있다.                                                                       |
| 쿠폰 발급  | 선착순으로 제공되는 쿠폰에 대해 <br/>다수의 사용자가 동시에 발급을 요청                                | 쿠폰의 총 발급 가능 수량을 초과하여 중복 발급되는 문제가 발생할 수 있다.                                                                                              |
| 재고 차감  | 특정 상품의 마지막 재고를 두고 <br/>여러 사용자가 동시에 주문                                     | 재고가 0보다 작은 음수 값으로 떨어지면서 실제 재고 이상으로 판매되는 문제가 발생할 수 있다.                                                                                   |
| 재고 복원  | 사용자가 주문을 취소하여 재고를 복원하는 과정에서<br/>동일한 주문 취소 요청이 동시에 여러 번 처리                 | 실제 취소된 수량보다 많은 재고가 복원되어 데이터 정합성이 깨질 수 있다.                                                                                               |
| 결제     | 사용자가 주문에 대한 결제를 시도할 때<br/>반복적인 클릭으로 인해 동일한 주문에 대한 <br/>결제 요청이 동시에 여러 번 전송 | 이미 결제가 성공적으로 처리되었음에도 다른 결제 요청이 다시 처리되어 사용자에게 금액이 이중으로 청구되는 문제가 발생할 수 있다. <br/>또한 이로 인해 하나의 주문에 대해 여러 개의 결제 성공 기록이 생성되어 데이터 정합성이 깨지게 된다. |

### 3. 문제 분석
- **근본 원인:** 공유 자원에 대한 동시성 제어의 부재

현재 시스템이 겪고 있는 문제들의 근본적인 원인은 **여러 트랜잭션이 공유 자원에 동시에 접근하여 수정할 때 발생할 수 있는 `경쟁 상태(Race Condition)`를 제어하는 부분 없기 때문**이다.
  각 트랜잭션은 독립적으로 실행되지만 포인트 잔액, 상품 재고, 쿠폰 수량과 같은 데이터는 모든 트랜잭션이 공유하는 자원이다. 동시성 제어가 없는 환경에서는 다음과 같은 문제가 발생한다.
1. **데이터 조회 :** 트랜잭션 A가 특정 시점의 데이터를 읽는다(재고 10개).
2. **다른 트랜잭션의 끼어들기:** 트랜잭션 A가 데이터를 처리하는 동안, 트랜잭션 B가 끼어들어 동일한 데이터를 읽는다. 아직 트랜잭션 A의 변경 사항이 데이터베이스에 반영되지 않았기 때문에 트랜잭션 B는 이전 데이터(재고 10개)를 기준으로 작업을 시작한다.
3. **데이터 수정 :** 트랜잭션 A가 재고를 1개 차감하고 결과를 데이터베이스에 반영한다. (재고 9개)
4. **데이터 덮어쓰기 :** 트랜잭션 B 또한 재고를 1개 차감한 후 결과를 반영한다. 하지만 트랜잭션 B가 처리를 시작할 때 읽었던 재고는 10개였으므로 여기서 1개를 뺀 9개를 데이터베이스에 최종적으로 기록한다.

**결과적으로 두 명의 사용자가 상품을 구매하여 재고가 총 2개 차감되어야 하지만 시스템에는 1개만 차감된 것으로 기록된다.** 이러한 데이터 불일치는 결제, 포인트, 쿠폰 등 동시 요청이 빈번한 모든 기능에서 동일하게 발생할 수 있으며 이는 시스템의 신뢰도를 떨어트리는 직접적인 원인이 된다.


### 4. 해결 방안 모색 및 선정
- **고려된 해결 방안:**


| 구분      | 비관적 락                                  | 낙관적 락                         |
|---------|----------------------------------------|-------------------------------|
| **개념**  | 데이터에 접근할 때 Lock을 걸어 다른 트랜잭션의 접근을 막는 방식 | 버전을 관리하여 데이터 수정 시 충돌을 감지하는 방식 |
| **장점**  | 데이터 정합성을 확실히 보장                        | 동시성이 높아 성능상 이점                |
| **단점**  | Lock으로 인한 성능 저하 및 데드락 발생 가능성           | 롤백 처리 로직 추가 구현 필요             |
| **적합성** | 충돌이 빈번하게 예상되는 경우                       | 충돌이 드물게 예상되는 경우               |
- **최종 해결 방안 선정:**

  - **낙관적 락 적용**
    - **대상 기능:** 포인트 충전, 주문, 결제
    - **적용 이유:** 해당 기능들은 특정 사용자에게 한정된 작업으로 동시에 여러 사용자가 같은 데이터를 수정하려는 충돌 가능성이 비교적 낮다.
    - **해결 방식:** 데이터에 버전을 부여하는 `낙관적 락`을 사용한다. 데이터를 수정할 때 버전을 확인하고 혹시 다른 트랜잭션이 먼저 데이터를 변경했다면 현재 트랜잭션을 실패 처리하고 재시도를 유도한다. 이를 통해 불필요한 락으로 인한 성능 저하를 최소화하면서 데이터의 정합성을 보장한다.

  - **비관적 락 적용**
    - **대상 기능:** 쿠폰 발급, 재고 차감 및 복원
    - **적용 이유:** 한정된 수량의 쿠폰이나 재고는 많은 사용자의 요청이 동시에 몰려 데이터 충돌 발생 빈도가 높을 것으로 예상된다.
    - **해결 방식:** 데이터에 직접 락을 걸어 다른 트랜잭션의 접근을 막는 `비관적 락`을 적용한다. 트랜잭션이 리소스를 독점하여 데이터의 일관성을 강력하게 보장하기 때문에 재고가 음수가 되거나 쿠폰이 중복 발급되는 등의 문제를 원천적으로 방지할 수 있다.